# buffer overflow 0

### Approach used
We will first observe the source file 'vuln.c' and we can see that first it contains 'sigsegv' which means that we will get the flag if we do a segmentation fault which basically means that if we crash the program we will get the flag. Later in the code we can see the 'gets' command which is a very dangerous command and is not used now because there is no check for buffer overrun hence very easy to break.

![image](https://github.com/UselessAaka/picoCTF-Writeups/assets/148384618/be75b994-0e86-4562-befa-252fdce75edd)
![image](https://github.com/UselessAaka/picoCTF-Writeups/assets/148384618/44d1b3e6-f934-458b-aba1-815ac1023aad)

Now we will use the netcat command 'nc saturn.picoctf.net 55984' to connect to this then we will write something in the inpu, for example:

![image](https://github.com/UselessAaka/picoCTF-Writeups/assets/148384618/bc2cc458-1b7e-48f4-9428-9dc23443ce6e)

the program exited, this means we need a more longer input to get the segmentation fault, so I type:

![image](https://github.com/UselessAaka/picoCTF-Writeups/assets/148384618/a2132a29-a638-47d7-a9f6-ee89f842f3cb)

### Flag 
> picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
### Resources used
Man page of [gets](https://man7.org/linux/man-pages/man3/gets.3.html) and [phoenixNAP Sigsegv](https://phoenixnap.com/kb/sigsegv#:~:text=check%20kernel%20logs.-,What%20Is%20SIGSEGV%3F,as%20C%20and%20C%2B%2B.) to get more info on signal command and sigsegv, etc.
